<<<BEGIN_FILE>>>
RelativePath:java\com\web\incident\controller
FileName:IncidentController.java
FileSize:4591
<<<BEGIN_CONTENT>>>
package com.web.incident.controller;
























@Api(tags = {"INCIDENT MANAGEMENT"})
@RestController
@RequestMapping("/mra/incident")
public class IncidentController extends BaseController {

    @Autowired
    private IncidentService incidentService;
    
    @ApiOperation(value = "export Incident")
    @PostMapping("/exportIncident")
    public void exportDataIncident(HttpServletResponse response, @RequestBody IncidentExportRequest request) {
        logger.info("IncidentController.exportIncident request:{}", request);
        try {
            Map<String, Object> map = new HashMap<>();
           
            if (StringUtils.isNotEmpty(request.getOwnerDept())) {
                map.put("ownerDept", request.getOwnerDept());
            }
            
            if (StringUtils.isNotEmpty(request.getPrimaryRiskType())) {
                map.put("primaryRiskType", request.getPrimaryRiskType());
            }
            
            
            DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd");

            if (StringUtils.isNotEmpty(request.getIdentificationDateFrom())) {
                String fromDate = request.getIdentificationDateFrom();
                LocalDate startDate = LocalDate.parse(fromDate, fmt);
                map.put("identificationDateFrom", startDate.toString());
            }
            
            if (StringUtils.isNotEmpty(request.getIdentificationDateTo())) {
                String toDate = request.getIdentificationDateTo();
                LocalDate endDate = LocalDate.parse(toDate, fmt);
                map.put("identificationDateTo", endDate.toString());
            }


            List<IncidentExport> incidentExportList = incidentService.exportIncident(map);
            
            logger.info("IncidentController.exportIncident size {}", incidentExportList.size());
            ExcelUtil<IncidentExport> incidentExcelUtil = new ExcelUtil<>(IncidentExport.class);
            incidentExcelUtil.exportExcel(response, incidentExportList, "Incident", "");
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }

    @ApiOperation(value = "Query Incident List")
    @GetMapping("/list")
    public AjaxResult getIncidentList(
            @RequestParam(required = false) String incidentNo,
            @RequestParam(required = false) String incidentStatus,
            @RequestParam(required = false) String ownerDept,
            @RequestParam(required = false) String primaryRiskType,
            @RequestParam(required = false) String identificationDateFrom,
            @RequestParam(required = false) String identificationDateTo
    ) {
        Map<String, Object> params = new HashMap<>();
        if (StringUtils.isNotEmpty(incidentNo)) {
            params.put("incidentNo", incidentNo);
        }
        if (StringUtils.isNotEmpty(incidentStatus)) {
            params.put("incidentStatus", incidentStatus);
        }
        if (StringUtils.isNotEmpty(ownerDept)) {
            params.put("ownerDept", ownerDept);
        }
        if (StringUtils.isNotEmpty(primaryRiskType)) {
            params.put("primaryRiskType", primaryRiskType);
        }

        if (StringUtils.isNotEmpty(identificationDateFrom)) {
            params.put("identificationDateFrom", identificationDateFrom);
        }
        if (StringUtils.isNotEmpty(identificationDateTo)) {
            params.put("identificationDateTo", identificationDateTo);
        }

        List<Incident> incidents = incidentService.selectIncidentList(params);
        return AjaxResult.success(incidents);
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>
RelativePath:java\com\web\incident\dao
FileName:IncidentMapper.java
FileSize:652
<<<BEGIN_CONTENT>>>
package com.web.incident.dao;







@Repository
public interface IncidentMapper {
    /**
     * Query incident list with filters
     *
     * @param map Filter parameters
     * @return List of incidents
     */
    List<Incident> selectIncidentList(Map<String, Object> map);

    /**
     * Query paginated incident list
     *
     * @param map Pagination and filter parameters
     * @return List of incidents
     */
    List<Incident> selectIncidentPage(Map<String, Object> map);


}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>
RelativePath:java\com\web\incident\entity
FileName:Incident.java
FileSize:6641
<<<BEGIN_CONTENT>>>
package com.web.incident.entity;













@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
@TableName("web.IMP_INCIDENT")
public class Incident {
    @TableId("auto_id")
    @Excel(name = "ID")
    private Long autoId;


    @TableField("incident_no")
    @Excel(name = "Incident No")
    private String incidentNo;

    @TableField("incident_type")
    @Excel(name = "Incident Type")
    private String incidentType;

    @TableField("incident_status")
    @Excel(name = "Status")
    private String incidentStatus;

    @TableField("occurrence_date")
    @Excel(name = "Occurrence Date")
    private Date occurrenceDate;

    @TableField("identification_date")
    @Excel(name = "Identification Date")
    private Date identificationDate;

    @TableField("incident_title")
    @Excel(name = "Title")
    private String incidentTitle;

    @TableField("identified_by")
    @Excel(name = "Incident Identifier Department")
    private String identifiedBy;

    @TableField("owner_department")
    @Excel(name = "Incident Owner Department")
    private String ownerDepartment;

    @TableField("incident_description")
    @Excel(name = "Description")
    private String incidentDescription;

    @TableField("risk_rating")
    @Excel(name = "Risk Rating")
    private String riskRating;

    @TableField("primary_risk_type")
    @Excel(name = "Primary Impacted Risk Area")
    private String primaryRiskType;

    @TableField("primary_level_ii_risk")
    @Excel(name = "Primary Level II Risk")
    private String primaryLevelIiRisk;

    @TableField("secondary_risk_type")
    @Excel(name = "Secondary Risk Type")
    private String secondaryRiskType;

    @TableField("secondary_level_ii_risk")
    @Excel(name = "Secondary Level II Risk")
    private String secondaryLevelIiRisk;

    @TableField("primary_owner_dept")
    @Excel(name = "IRM Primary Owner Dept")
    private String primaryOwnerDept;

    @TableField("secondary_owner_dept")
    @Excel(name = "IRM Secondary Owner Dept")
    private String secondaryOwnerDept;

  
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.incident.entity;


@JsonInclude(JsonInclude.Include.NON_NULL)
public class IncidentExport {
    private static final long serialVersionUID = -11534341125235L;
    @Excel(name = "Incident No")
    private String incidentNo;

    @Excel(name = "Incident Type")
    private String incidentType;

    @Excel(name = "Status")
    private String incidentStatus;

    @Excel(name = "Occurrence Date")
    private String occurrenceDate;

    @Excel(name = "Identification Date")
    private String identificationDate;

    @Excel(name = "Title")
    private String incidentTitle;

    @Excel(name = "Incident Identifier Department")
    private String identifiedBy;

    @Excel(name = "Incident Owner Department")
    private String ownerDepartment;

    @Excel(name = "Description")
    private String incidentDescription;

    @Excel(name = "Primary Impacted Risk Area")
    private String primaryRiskType;

    @Excel(name = "IRM Primary Owner Dept")
    private String primaryOwnerDept;

    @Excel(name = "IRM Secondary Owner Dept")
    private String secondaryOwnerDept;
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>


public class IncidentExportRequest {
    private String ownerDept;
    private String primaryRiskType;
    private String identificationDateFrom;
    private String identificationDateTo;
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.incident.service;









public interface IncidentService {
    /**
     * Query incident list with filters
     */
    List<Incident> selectIncidentList(Map<String, Object> map);

    /**
     * Get paginated incidents
     */
    List<Incident> selectIncidentPage(Map<String, Object> map);
    
    /** Download IMP_INCIDENT partial data */
    List<IncidentExport> exportIncident(Map<String,Object> map);
}
<<<END_CONTENT>>>
<<<END_FILE>>>

package com.web.incident.service.serviceImpl;


@Service
public class IncidentServiceImpl implements IncidentService {

    @Autowired
    private IncidentMapper incidentMapper;



    @Override
    public List<Incident> selectIncidentList(Map<String, Object> map) {
        return incidentMapper.selectIncidentList(map);
    }

    @Override
    public List<Incident> selectIncidentPage(Map<String, Object> map) {
        return incidentMapper.selectIncidentPage(map);
    }
    
    @Override
    public List<IncidentExport> exportIncident(Map<String,Object> map) {
        List<Incident> incidentList = incidentMapper.selectIncidentList(map);
        List<IncidentExport> incidentExports = new ArrayList<>();
        if(StringUtils.isNotEmpty(incidentList)){
            SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
            incidentList.forEach(item -> {
                IncidentExport export = new IncidentExport();
                BeanUtils.copyProperties(item, export, "occurrenceDate", "identificationDate");
                if (item.getOccurrenceDate() != null) {
                    export.setOccurrenceDate(formatter.format(item.getOccurrenceDate()));
                } else {
                    export.setOccurrenceDate("");
                }
                if (item.getIdentificationDate() != null) {
                    export.setIdentificationDate(formatter.format(item.getIdentificationDate()));
                } else {
                    export.setIdentificationDate("");
                }
                incidentExports.add(export);
            });
        }
        return incidentExports;
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>

<<<BEGIN_FILE>>>

package com.web.mra.controller;


public class DetectionController {

    private final DetectionService detectionService;
    private final DetectionFileService detectionFileService;
    private final AuditService auditService;

    @ApiOperation(value = "Execute Near Miss Detection")
    @GetMapping("/detection/list/{detectionId}")
    public AjaxResult executeNearMissDetection(@PathVariable Integer detectionId) {
        try {
            String result = detectionService.detectNearMiss(detectionId, LocalDate.now(), true);
            
            auditService.logAudit(null, "FORCE_DETECT_NEAR_MISS", "Executed near miss detection for ID: " + detectionId,
                    null, null, null, null);
            return AjaxResult.success(result);
        } 
    }

    @ApiOperation(value = "Get Last 8 days Miss Detection Results")
    @GetMapping("/detection/selectWeekly")
    public AjaxResult getWeeklyNearMissDetections() {
        try {
            Map<String, Object> results = detectionService.getWeeklyNearMiss();
            return AjaxResult.success(results);
        } 
    }

    @ApiOperation(value = "Get history of near miss event")
    @GetMapping("/detection/selectNearMissHistory")
    public AjaxResult getNearMissHistory() {
        try {
            Map<String, Object> results = detectionService.getNearMissHistory();
            return AjaxResult.success(results);
        } 
    }

    @ApiOperation(value = "Upload File")
    @PostMapping("/upload")
    public  AjaxResult uploadFiles(@RequestParam("file") MultipartFile[] files) {
        try {
            List<String> fileList = detectionFileService.uploadFiles(files);
            List<String> results = detectionService.fileTriggerDetection(fileList);
            
            String fileNames = String.join(", ", fileList);
            auditService.logAudit(null, "FILE_UPLOAD", "Uploaded files: " + fileNames,
                    null, null, null, null);
            return AjaxResult.success(results);
        } 
    }

    @ApiOperation(value = "Get File list")
    @GetMapping("/files")
    public  AjaxResult listFiles(@RequestParam(defaultValue = "") String path) {
        try {
            List<FileDTO> results = detectionFileService.listFiles(path);
            return AjaxResult.success(results);
        } 
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.controller;

@Api(tags = {"DYNAMIC TABLE MANAGEMENT"})
@RestController
@RequestMapping("/mra/admin")
@RequiredArgsConstructor
@Slf4j
public class DynamicTableController extends BaseController {

    private final DynamicTableService dynamicTableService;
    private final DatabaseMetadataService metadataService;

    @ApiOperation(value = "Get All Table Names")
    @GetMapping("/tables")
    public AjaxResult getAllTables() {
        try {
            List<String> tables = metadataService.getAllTables();
            // log.info("Returning {} tables", tables.size());
            return AjaxResult.success(tables);
        } 
    }

    @ApiOperation(value = "Get Table Metadata")
    @GetMapping("/metadata/{tableAlias}")
    public AjaxResult getTableMetadata(@PathVariable String tableAlias) {
        if (!dynamicTableService.isReadableTable(tableAlias)) {
            return AjaxResult.error("Invalid or non-readable table : " + tableAlias);
        }
        
        try {
            List<TableMetadataDTO> metadata = metadataService.getTableMetadata(tableAlias);
            return AjaxResult.success(metadata);
        } 
    }

    @ApiOperation(value = "Get Table Data with Pagination")
    @GetMapping("/table/{tableAlias}")
    public AjaxResult getTableData(
            @PathVariable String tableAlias,
            @RequestParam(defaultValue = "1") int page,
            @RequestParam(defaultValue = "10") int size
    ) {
        if (!dynamicTableService.isReadableTable(tableAlias)) {
            return AjaxResult.error("Invalid or non-readable table : " + tableAlias);
        }
        try {
            PageResponse<Map<String, Object>> pageResponse =
                    dynamicTableService.getTableData(tableAlias, page, size);
            return AjaxResult.success(pageResponse);
        } 
    }

    @ApiOperation(value = "Update Existing Record")
    @PutMapping("/table/{tableAlias}/{id}")
    public AjaxResult updateRecord(
            @PathVariable String tableAlias,
            @PathVariable Long id,
            @RequestBody Map<String, Object> record
    ) {
        if (!dynamicTableService.isWriteableTable(tableAlias)) {
            return AjaxResult.error("Invalid or non-writeable table : " + tableAlias);
        }
        try {
            Map<String, Object> updatedRecord = dynamicTableService.updateRecord(tableAlias, id, record);
            return AjaxResult.success("Record updated successfully", updatedRecord);
        } 
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.dto;




@Data
@Builder
public class DetectionComponentMetaDTO {
    private Long autoId;
    private Integer detectionComponentId;
    private String componentLabels;
    private Integer componentDataTypes;
    private Integer detectionComponentSource;
    private String detectionComponentDescription;
    private String isActive;
}
<<<END_CONTENT>>>
<<<END_FILE>>>

package com.web.mra.dto;

@Data
@Builder
public class DetectionDataMartMetaDTO {
    private Long autoId;
    private Integer detectionComponentId;
    private String sqlTemplate;
    private String sqlParams;
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.dto;

@Data
@Builder
public class DetectionEmailMetaDTO {
    private Long autoId;
    private String userName;
    private String userDepartment;
    private Integer emailGroupBitmap;
    private String isActive;
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.dto;

public class DetectionExcelMetaDTO {
    private Long autoId;
    private Integer detectionComponentId;
    private String excelFileName;
    private String sheetName;
    private String cellPositions;
    private String cellParams;
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.dto;




@Data
@Builder
public class DetectionMatchMetaDTO {
    private Long autoId;
    private Integer leftdetectionComponentId;
    private Integer rightdetectionComponentId;
    private Integer matchRule;
    private Double matchThreshold;
    private String isActive;
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.dto;




/**
 * DTO representing the result of a match comparison.
 */
@Data
@Builder
public class DetectionMatchResultDTO {
    private final boolean matches;
    private final String leftValue;
    private final Integer matchRule;
    private final String errorMessage;
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.dto;




@Data
@Builder
public class DetectionMetaDTO {
    private Long autoId;
    private Integer detectionId;
    private String detectionDept;
    private String detectionDesc;
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.dto;

@Data
@Builder
public class DetectionTextMetaDTO {
    private Long autoId;
    private Integer detectionComponentId;
    private String textFileName;
    private String textRegexJson;
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.dto;
@Data
@NoArgsConstructor
@AllArgsConstructor
public class FileDTO {
    private String name;
    private String type;
    private String path;
    private Long size;
    private Long modifiedDate;
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.dto;





@Data
public class PageResponse<T> {
    private List<T> content;
    private long total;
    private int page;
    private int size;
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.dto;




@Data
@Builder
public class TableMetadataDTO {
    private String columnName;
    private String dataType;
    private boolean nullable;
    private boolean isPrimaryKey;
    private Integer maxLength;
}
<<<END_CONTENT>>>
<<<END_FILE>>>


<<<BEGIN_FILE>>>

package com.web.mra.service;


@Service
@RequiredArgsConstructor
public class AuditService {

    private final NamedParameterJdbcTemplate jdbcTemplate;

    public void logAudit(String userId, String action, String description,
            String tableName, String fieldName, String oldValue, String newValue) {
        String sql = " INSERT INTO web.IMP_DETECTION_AUDIT_TRAIL " +
                "(user_id, action, action_description, table_name, field_name, old_value, new_value) " +
                "VALUES (:userId, :action, :description, :tableName, :fieldName, :oldValue, :newVaule)";
        
        Map<String, Object> params = new HashMap<>();
        if (userId == null) {
            LoginUser loginUser = SecurityUtils.getLoginUser();
            AiosPortalUser user = loginUser.getUser();
            userId = user.getUserName();
        }
        params.put("userId", userId);
        params.put("action", action);
        params.put("description", description);
        params.put("tableName", tableName);
        params.put("fieldName", fieldName);
        params.put("oldValue", oldValue);
        params.put("newVaule", newValue);
       
        
        jdbcTemplate.update(sql, params);
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.service;

public class DatabaseMetadataService {

    private final JdbcTemplate jdbcTemplate;

    public List<String> getAllTables() {
        String sql;
        // log.info("Retrieving all tables from DatabaseMetadataService");
        sql = " SELECT t.TABLE_NAME as TableName FROM INFORMATION_SCHEMA.TABLES t " +
                "WHERE  t.TABLE_TYPE = 'BASE TABLE' and  t.TABLE_SCHEMA = 'web' " +
                "AND (t.TABLE_NAME =  'IMP_DETECTION_DICT' OR t.TABLE_NAME = 'IMP_DETECTION_EXCEL_META')" + 
                "ORDER BY  t.TABLE_NAME ";

        return jdbcTemplate.queryForList(sql, String.class);
    }

    public List<TableMetadataDTO> getTableMetadata(String tableName) {
        String sql;
    


        return jdbcTemplate.query(sql,
                (rs, rowNum) -> TableMetadataDTO.builder()
                        .columnName(rs.getString("COLUMN_NAME"))
                        .dataType(mapDataType(rs.getString("DATA_TYPE")))
                        .nullable("YES".equals(rs.getString("IS_NULLABLE")))
                        .isPrimaryKey("PRI".equals(rs.getString("COLUMN_KEY")))
                        .maxLength(rs.getObject("CHARACTER_MAXIMUM_LENGTH", Integer.class))
                        .build(),
                tableName
        );
    }

}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.service.detection;





@Service
@RequiredArgsConstructor
@Slf4j
public class DetectionDataMartService {
    private final NamedParameterJdbcTemplate jdbcTemplate;
    private final ObjectMapper objectMapper;

    public Object detectDataMart(DetectionDataMartMetaDTO dataMartMeta) {
        try {
            Map<String, Object> sqlParams = parseSqlParams(dataMartMeta.getSqlParams());
            if ("HardCode".equals(dataMartMeta.getSqlTemplate())) {
                String sqlTemplate = "select  a.contract_id, b.amount_lcy from " + 
                        "(  select  contract_id, dw_contract_id from dim_contract " + 
                        "  where contract_id in ( 'USD140050001', 'USD140060001', 'CNY140060001', 'USD113080001', 'CNY113080001', 'USD140650001') " + 
                        "    and CONVERT(date, :eventDate, 112)  between effective_from_date and effective_to_date " + 
                        ") a " + 
                        " ,  fact_balance b " + 
                        "where " + 
                        " a.dw_contract_id = b.dw_contract_id " + 
                        "and b.as_of_date =:eventDate";
                List<Map<String, Object>> results = executeQuery(sqlTemplate, sqlParams);
                 if (results.isEmpty()) return "";
                 return objectMapper.writeValueAsString(results);
            } else {
                return "";
            }
        } 
    }

    private Map<String, Object> parseSqlParams(String sqlParams) throws Exception {
        if (sqlParams == null || sqlParams.isEmpty()) {
            return new HashMap<>();
        }
        Map<String, Object> params = objectMapper.readValue(sqlParams, new TypeReference<Map<String, Object>>() {});
        params.entrySet().forEach(entry -> {
            if ("AsOfDate".equals(entry.getValue())) {
                entry.setValue(getAsOfDate("yyyyMMdd"));
            }
        });
        return params;
    }

    private List<Map<String, Object>> executeQuery(String sqlTemplate, Map<String, Object> params) {
        return jdbcTemplate.queryForList(sqlTemplate, params);
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.service.detection;



@Service
@RequiredArgsConstructor
@Slf4j
public class DetectionEmailService {
    @Autowired
    private EmailUtil emailUtil;

    @Autowired
    private UserService userService;
    
    final private String RDALINK = "<a href='https://rdareport-prod/rda/#/login'>Click here to access</a><br>";
    
    public Boolean SendEmailNearMissEventUploadFiles(List<DetectionEmailMetaDTO> emailConfigs, Map<String, String> status, String emailList) {
        log.info(" email for upload file");
        try {            
            
            // email body
            StringBuilder emailContent = new StringBuilder()
                    .append("<u><i>Please DO NOT REPLY. This is an automated notification from the RDA Reporting Platform Near Miss Detection Module.</u></i>   <br>")
                    .append("<br> Dear All,<br>");
            emailContent.append("<br>" +
                    "Friendly Reminder, please upload your daily files onto RDA Reporting Platform Near Miss Detection Module for below tasks <b><u>before 12PM today</u></b>.  <br>" +
                    "<br>");
           
            // log.info(" email content: " + emailContent.toString());
            emailUtil.sendSimpleHtmlMail(emailContent.toString(), emailList, "", "[Do Not Reply] Auto-Reminder: Please Upload Files to RDA Near Miss Detection Module before 12PM. ");
 
        } catch (Exception e) {
            log.info("Send email failed for file upload reminder. Error message: ", e);
            return Boolean.FALSE;
        }
        return Boolean.TRUE;
    }

    public Boolean SendEmailNearMissEventsDetectedNonORD(String department, List<DetectionEmailMetaDTO> emailConfigs, String nonUserEmails, int count, Map<String, String> statusCount, Map<String, String> status, Map<String, String> runTime) {
        log.info(" email by dept {}: ", department);
        try {
            Date d = new Date();
            SimpleDateFormat formatter = new SimpleDateFormat("MM/dd/yy");
            String formattedDate = formatter.format(d);

            String emailList = "";
            List<DetectionEmailMetaDTO> departmentUsers = emailConfigs.stream().filter(config -> config.getUserDepartment().equals(department)).collect(Collectors.toList());
            for (DetectionEmailMetaDTO user : departmentUsers) {
                LambdaQueryWrapper<AiosPortalUser> userQuery = new LambdaQueryWrapper<>(AiosPortalUser.class).eq(AiosPortalUser::getUserName, user.getUserName());
                AiosPortalUser portalUser = userService.getOne(userQuery);
                // Skip if user not found or no email address
                if (portalUser == null || StringUtils.isEmpty(portalUser.getEmail())) {
                    log.warn("User not found or no email address for username: " + user.getUserName());
                    continue;
                }
                emailList = emailList + portalUser.getEmail() + ";"; 
                log.info(" email addr: " + portalUser.getEmail());
            }
                
            if (emailList.length() > 0 && nonUserEmails != null && nonUserEmails.length() > 0) {
                emailList = emailList + nonUserEmails;
            } else if (emailList.length() > 0) {
                emailList = emailList.substring(0, emailList.length() - 1);
            } else if (nonUserEmails != null && nonUserEmails.length() > 0){
                emailList = nonUserEmails;
            } else {
                log.info("No email receiver in : " + department);
                return Boolean.FALSE;
            }
                
            // email body
            StringBuilder emailContent = new StringBuilder()
                        .append("<u><i>Please DO NOT REPLY. This is an automated notification from the RDA Reporting Platform Near Miss Detection Module.</u></i>   <br>")
                        .append("<br> Dear All,<br>");
            emailContent.append("<br>" +
                    String.valueOf(count) + " near miss events relevasnt to your department have been detected on " + formattedDate + ":  <br>" +
                    "<br>");
            
            emailContent.append("<table border=1>");
            
            // log.info(" email content: " + emailContent.toString());
            emailUtil.sendSimpleHtmlMail(emailContent.toString(), emailList, "", "[Do Not Reply] Auto Notification: " + String.valueOf(count) + " Near Miss Events Detected - " + formattedDate);
            
        } 
        return Boolean.TRUE;
    }

    public Boolean SendEmailNearMissEventsDetectedORD(int totalCount, Map<String, String> nearMissCount, Map<String, String> nearMissStatus, 
            Map<String, String> nearMissRunTime, Map<String, String> nearMissDept, String filePath,
            String ormEmail, String ccEmail) {
        log.info(" email by dept ORD: ");
        try {
            Date d = new Date();
            SimpleDateFormat formatter = new SimpleDateFormat("MM/dd/yy");
            String formattedDate = formatter.format(d);

            emailContent.append("<tr><th>Near Miss Task Name</th><th>Department</th><th>Status</th><th>Count of Detected Events</th><th>Run Time</th></tr>");

            for (Map.Entry<String, String> entry : nearMissCount.entrySet()) {
                
                emailContent.append("</tr>");
            }
            emailContent.append("</table>");
            emailContent.append("<br>");
            emailContent.append("Link to the RDA Reporting Platform Near Miss Detection Module: " + RDALINK +
                    "<br>" +
                    "Should you have any technical questions, please contact ERM/RDA administrators.<br>" +
                    "<br>" +
                    "<br>" +
                    "Thank you!<br>" +
                    "ERM-RDA Team");
            log.info(" email to: " + ormEmail + " cc: " + ccEmail);
            String emailTitle = "[Do Not Reply] Auto Notification: " + String.valueOf(totalCount) + " Near Miss Events Detected - " + formattedDate;
            emailUtil.sendHtmlMailWithAttachments(emailContent.toString(), ormEmail, ccEmail, emailTitle, filePath);
        } catch (Exception e) {
            log.info("Send email failed for ORD", e);
            return Boolean.FALSE;
        }
        return Boolean.TRUE;
    }
    
    public Boolean SendEmailNearMissEventsDetectedERM(String fileList, String ermEmail) {
        log.info(" Send email to ERM Admin for existing file in shared folder ");
        try {StringBuilder emailContent = new StringBuilder()
                        .append("<u><i>Please DO NOT REPLY. This is an automated notification from the RDA Reporting Platform Near Miss Detection Module.</u></i>   <br>")
                        .append("<br> Dear ERM Administrator,<br> <br>")
                        .append("<br>Please see the attached file list existing in shared folder, " + fileList + "<br>Thank you!<br>ERM-RDA Team");
            String emailTitle = "[Do Not Reply] Auto Notification: file existing in shared folder";
            emailUtil.sendSimpleHtmlMail(emailContent.toString(), ermEmail, "", emailTitle);
        } catch (Exception e) {
            log.info("Send email failed for ERM", e);
            return Boolean.FALSE;
        }
        return Boolean.TRUE;
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.service.detection;


public class DetectionExcelService {
    private static final ObjectMapper objectMapper = new ObjectMapper();
    private final DetectionFileService detectionFileService;

    public Object detectExcel(DetectionExcelMetaDTO excelMeta) {
        try {
            validateExcelMeta(excelMeta);
            return processExcelFile(excelMeta);
        } catch (Exception e) {
            String errorMsg = String.format("Excel detection failed for ID: %d", excelMeta.getDetectionComponentId());
            log.error(errorMsg, e);
            throw new DetectionServiceException(errorMsg, e);
        }
    }

    private void validateExcelMeta(DetectionExcelMetaDTO excelMeta) {
        if (excelMeta.getExcelFileName() == null || excelMeta.getExcelFileName().isEmpty()) {
            throw new IllegalArgumentException("Excel file name cannot be null or empty");
        }
        if (excelMeta.getSheetName() == null || excelMeta.getSheetName().isEmpty()) {
            throw new IllegalArgumentException("Sheet name cannot be null or empty");
        }
    }

    private String processExcelFile(DetectionExcelMetaDTO excelMeta) throws Exception {
        String filePath = detectionFileService.processFile(excelMeta.getExcelFileName(),
                LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd")));

        if (filePath.isEmpty()) {
            return "";
        }
        return parseExcel(filePath, excelMeta.getSheetName(), excelMeta.getCellPositions(), excelMeta.getCellParams());
    }

    private String parseExcel(String filePath, String sheetNamePattern, String cellPositions, String cellParams)
            throws Exception {
        List<Map<String, Object>> result = new ArrayList<>();
        
        File excelFile = new File(filePath);
        try (FileInputStream fis = new FileInputStream(excelFile); Workbook workbook = new XSSFWorkbook(fis)) {

            // Split sheet pattern to handle multiple sheets
            String[] sheetPatterns = sheetNamePattern.split("\\|");
            int sheetSequence = 1;

            // Process each matching sheet
            for (String pattern : sheetPatterns) {
                Sheet matchingSheet = null;
                log.info("Match file {} pattern: {}", filePath, pattern);
                // Find matching sheet for current pattern
                for (int i = 0; i < workbook.getNumberOfSheets(); i++) {
                    String sheetName = workbook.getSheetName(i);
                    if (Pattern.matches(pattern.trim(), sheetName)) {
                        matchingSheet = workbook.getSheetAt(i);
                        log.info(" Match file {} sheet matched: {}", filePath, sheetName);
                        break;
                    }
                }

                if (matchingSheet == null) {
                    log.error("No sheet in Excel matched by name pattern {}", pattern);
                    return "";
                }
                List<Map<String, Object>> sheetResult = new ArrayList<>();
                Map<String, Object> aggregationResult = new HashMap<>();

                // Process cell positions for aggregations
                if (cellPositions != null && !cellPositions.isEmpty()) {
                    Map<String, Map<String, String>> positionsMap = objectMapper.readValue(cellPositions, Map.class);
                    if (positionsMap.containsKey(String.valueOf(sheetSequence))) {
                        processAggregations(matchingSheet, positionsMap.get(String.valueOf(sheetSequence)),
                                aggregationResult);
                        sheetResult.add(aggregationResult);
                    }
                }

                // Process cell parameters for key-value pairs
                if (cellParams != null && !cellParams.isEmpty()) {
                    Map<String, Map<String, String>> paramsMap = objectMapper.readValue(cellParams, Map.class);
                    if (paramsMap.containsKey(String.valueOf(sheetSequence))) {
                        processKeyValuePairs(matchingSheet, paramsMap.get(String.valueOf(sheetSequence)), sheetResult);
                    }
                }

                result.addAll(sheetResult);
                sheetSequence++;
            }

            if (result.isEmpty()) {
                return "[]";
            }
        } 
        String resultString = objectMapper.writeValueAsString(result);
        log.info(" parsel excel, result: " + resultString);
        return resultString;
    }

    
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.service.detection;



@Service
@Slf4j
public class DetectionFileService {

    private final String sharedFolder;
    private final String archiveFolder;

    // Constructor injection for configuration properties
    public DetectionFileService(@Value("${spring.filepath.shared}") String sharedFolder,
            @Value("${spring.filepath.archive}") String archiveFolder) {
        this.sharedFolder = sharedFolder;
        this.archiveFolder = archiveFolder;
    }

    /**
     * Processes a file based on the provided file name pattern and archive date.
     *
     * @param fileNamePattern The regex pattern for matching file names.
     * @param archiveDate     The date to use for archiving (format: yyyyMMdd).
     * @return The path of the processed file, or an empty string if no file is
     *         found.
     */
    public String processFile(String fileNamePattern, String archiveDate) {
        try {
            // Create Pattern from fileNamePattern
            Pattern pattern = Pattern.compile(fileNamePattern);

            // Get current date folder name
            String dateFolderName = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
            Path dateFolderPath = Paths.get(archiveFolder, dateFolderName);

            // Search in shared folder
            File sharedDir = new File(sharedFolder);
            File[] files = sharedDir.listFiles();
            if (files != null) {
                Arrays.sort(files, (f1, f2) -> Long.compare(f1.lastModified(), f2.lastModified()));
                for (File file : files) {
                    if (pattern.matcher(file.getName()).matches()) {
                        // Create date folder if it doesn't exist
                        Files.createDirectories(dateFolderPath);

                        // Move file to archive/date folder
                        Path targetPath = dateFolderPath.resolve(file.getName());
                        Files.move(file.toPath(), targetPath, StandardCopyOption.REPLACE_EXISTING);
                        return targetPath.toString();
                    }
                }
            }

            // If not found in shared folder, search in archive and date folder
            if (Files.exists(dateFolderPath)) {
                File[] dateFiles = dateFolderPath.toFile().listFiles();
                if (dateFiles != null) {
                    Arrays.sort(dateFiles, (f1, f2) -> Long.compare(f2.lastModified(), f1.lastModified()));
                    for (File file : dateFiles) {
                        if (pattern.matcher(file.getName()).matches()) {
                            return file.getAbsolutePath();
                        }
                    }
                }
            }

            return "";

        } catch (IOException e) {
            throw new DetectionServiceException("Error processing file: " + e.getMessage(), e);
        }
    }

    public String hasFileInSharedFolder() {
        File sharedDir = new File(sharedFolder);
        File[] files = sharedDir.listFiles();
        if (files != null && files.length > 0) {
            return Arrays.stream(files).map(File::getName).collect(Collectors.joining("; "));
        }
        return null;
    }

    public boolean filesAllReady(String fileNamePatterns) {
        if (fileNamePatterns == null || fileNamePatterns.isEmpty()) {
            return false;
        }
        
        String[] patterns = fileNamePatterns.split("\\|");
        for (String pattern : patterns) {
            String filePath = processFile(pattern, null);
            if (filePath == null || filePath.isEmpty()) {
                return false;
            }
        }
        return true;
    }
    
    public boolean fileInPattern(List<String> fileList, String fileNamePatterns) {
        if ( fileList == null ||  fileList.isEmpty() || fileNamePatterns == null || fileNamePatterns.isEmpty()) {
            return false;
        }
        
        String[] patterns = fileNamePatterns.split("\\|");
        for (String fileName : fileList) {
            for (String patternStr : patterns) {
                Pattern pattern = Pattern.compile(patternStr);
                if (pattern.matcher(fileName).matches()) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Searches for a file matching the pattern in the archive directory.
     *
     * @param archiveDir The archive directory to search in.
     * @param pattern    The regex pattern for matching file names.
     * @return The absolute path of the matching file, or null if no file is found.
     */
    private String searchInArchive(File archiveDir, Pattern pattern) {
        File[] dateFolders = archiveDir.listFiles();
        if (dateFolders != null) {
            for (File dateFolder : dateFolders) {
                if (dateFolder.isDirectory()) {
                    File[] files = dateFolder.listFiles();
                    if (files != null) {
                        for (File file : files) {
                            if (pattern.matcher(file.getName()).matches()) {
                                return file.getAbsolutePath();
                            }
                        }
                    }
                }
            }
        }
        return null;
    }

    public List<String> uploadFiles(MultipartFile[] files) {
        List<String> fileNames = new ArrayList<>();
        try {
            for (MultipartFile file : files) {
                // Save file
                String fileName = file.getOriginalFilename();
                Path filePath = Paths.get(sharedFolder, fileName);
                Files.copy(file.getInputStream(), filePath);
                fileNames.add(fileName);
            }
            return (fileNames);
        } catch (IOException e) {
            return fileNames;
        }
    }

    public List<FileDTO> listFiles(String relativePath) {
        try {
            Path dirPath = Paths.get(archiveFolder, relativePath);
            List<FileDTO> items = Files.list(dirPath).map(path -> {
                FileDTO dto = new FileDTO();
                dto.setName(path.getFileName().toString());
                dto.setPath(relativePath.isEmpty() ? path.getFileName().toString()
                        : relativePath + "/" + path.getFileName());
                dto.setType(Files.isDirectory(path) ? "directory" : "file");
                try {
                    dto.setModifiedDate(Files.getLastModifiedTime(path).toMillis());
                    if (!Files.isDirectory(path)) {
                        dto.setSize(Files.size(path));
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
                return dto;
            }).collect(Collectors.toList());

            return items;
        } catch (IOException e) {
            throw new RuntimeException("Failed to list files", e);
        }
    }

    public Resource loadFileAsResource(String relativePath) {
        try {
            Path filePath = Paths.get(archiveFolder, relativePath);
            Resource resource = new UrlResource(filePath.toUri());
            if (resource.exists()) {
                return resource;
            } else {
                throw new RuntimeException("File not found: " + relativePath);
            }
        } catch (MalformedURLException e) {
            throw new RuntimeException("File not found: " + relativePath, e);
        }
    }
    

    
    public String saveWBtoFile(Workbook wb) {
        try {
            // Get current date folder name
            String dateFolderName = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
            Path dateFolderPath = Paths.get(archiveFolder, dateFolderName);
            Files.createDirectories(dateFolderPath);

            String randomChars = UUID.randomUUID().toString().substring(0, 4).toUpperCase();
            String fileName = "NearMissEvents" + dateFolderName + "-" + randomChars + ".xlsx";
            Path filePath = dateFolderPath.resolve(fileName);
            
            try (OutputStream outputStream = Files.newOutputStream(filePath)) {
                wb.write(outputStream);
            }
            return filePath.toString();

        } 
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.service.detection;



@Service
@RequiredArgsConstructor
@Slf4j
public class DetectionMatchService {
    private final NamedParameterJdbcTemplate jdbcTemplate;
    private final ObjectMapper objectMapper;
    private final DetectionMetadataService detectionMetadataService;

    @Transactional
    public String executeMatchByDate(Integer detectionId, LocalDate eventDate) {
        validateParameters(detectionId, eventDate);

        try {
            List<DetectionMatchMetaDTO> matchRules = getActiveMatchRules(detectionId);
            return processMatchRules(matchRules, eventDate);
        } catch (Exception e) {
            String errorMsg = String.format("Match execution failed for detection ID: %d and date: %s",
                    detectionId, eventDate);
            log.error(errorMsg, e);
            throw new DetectionServiceException(errorMsg, e);
        }
    }

    private void validateParameters(Integer detectionId, LocalDate eventDate) {
        if (detectionId == null) {
            throw new IllegalArgumentException("Detection ID cannot be null");
        }
        if (eventDate == null) {
            throw new IllegalArgumentException("Event date cannot be null");
        }
    }

    private List<DetectionMatchMetaDTO> getActiveMatchRules(Integer detectionId) {
        String sql = "SELECT * FROM web.IMP_DETECTION_MATCH_META " +
                "WHERE left_detection_component_id / 100 = :detectionId " +
                "AND is_active = 'Y' " +
                "ORDER BY auto_id";

        Map<String, Object> params = Collections.singletonMap("detectionId", detectionId);

        return jdbcTemplate.query(sql, params, (rs, rowNum) ->
                DetectionMatchMetaDTO.builder()
                        .autoId(rs.getLong("auto_id"))
                        .leftdetectionComponentId(rs.getInt("left_detection_component_id"))
                        .rightdetectionComponentId(rs.getInt("right_detection_component_id"))
                        .matchRule(rs.getInt("match_rule"))
                        .matchThreshold(rs.getDouble("match_threshold"))
                        .isActive(rs.getString("is_active"))
                        .build()
        );
    }

    private String processMatchRules(List<DetectionMatchMetaDTO> matchRules, LocalDate eventDate) {
        List<JsonNode> allLeftValues = new ArrayList<>();

        for (DetectionMatchMetaDTO matchRule : matchRules) {
            boolean doneAll = false;
            try {
                String leftResult = detectionMetadataService.getDetectionResult(matchRule.getLeftdetectionComponentId(), eventDate);
                String rightResult = detectionMetadataService.getDetectionResult(matchRule.getRightdetectionComponentId(), eventDate);

                log.info(" leftResult in getDetectionResult : {}", leftResult);
                DetectionMatchResultDTO matchResult = compareResults(leftResult, rightResult, matchRule);
                saveMatchResult(matchRule, eventDate, matchResult);
                
                if (matchResult.getLeftValue() != null) {
                    JsonNode leftValues = objectMapper.readTree(matchResult.getLeftValue());
                    if (leftValues.isArray()) {
                        for (JsonNode value : leftValues) {
                            allLeftValues.add(value);
                        }
                    } else {
                        allLeftValues.add(leftValues);
                    }
                }
                
                // If match result is false, create incident and send email notification
                if (!matchResult.isMatches()) {
                    int detectionId =  matchRule.getLeftdetectionComponentId() / 100;
                    // Get department and description from detection metadata using component ID
                    DetectionMetaDTO detectionMeta = detectionMetadataService.getDetectionMetaConfig(detectionId);
                    String department = detectionMeta.getDetectionDept();
                    String description = detectionMeta.getDetectionDesc();

                    try {
                            log.info(" leftValue in matchResult: {}", matchResult.getLeftValue());
                            JsonNode leftValues = objectMapper.readTree(matchResult.getLeftValue());
                            if (leftValues.isArray()) {
                                for (JsonNode value : leftValues) {
                                    DetectionMatchResultDTO singleMatchResult = DetectionMatchResultDTO.builder()
                                            .matches(false)
                                            .leftValue(value.toString())
                                            .matchRule(matchResult.getMatchRule())
                                            .errorMessage(matchResult.getErrorMessage())
                                            .build();
                                    saveNearMissToIncident(matchRule, eventDate, singleMatchResult, department, description);
                                    // For detection ID 105 and 106, save only once
                                    if (detectionId == 105 || detectionId == 106) {
                                        doneAll = true;
                                        break;
                                    }
                                }
                            } else {
                                saveNearMissToIncident(matchRule, eventDate, matchResult, department, description);
                            }
                    } catch (Exception e) {
                        log.error("Error processing match rule ID: {}", matchRule.getAutoId(), e);
                    }
                }
            } catch (Exception e) {
                log.error("Error processing match rule ID: {}", matchRule.getAutoId(), e);
                handleMatchRuleError(matchRule, eventDate, e);
            }
            
            // OSD 105 & 106 paused once mismatched found.
            if (doneAll) {
                break;
            }
            
        }
        
        
        try {
            return objectMapper.writeValueAsString(allLeftValues);
        } 
    }

    
    private DetectionMatchResultDTO compareResults(String leftResult, String rightResult,
                                                   DetectionMatchMetaDTO matchRule) {
        if (leftResult == null || rightResult == null) {
            return createNoMatchResult("Missing detection results");
        }
        
        log.info("in compareResults: leftResult {}  -- rightResult {}", leftResult, rightResult);
        // No comparison, all found data are near miss events. Right component id is 0
        if (rightResult.trim().isEmpty()) {
            return DetectionMatchResultDTO.builder()
                    .matches((leftResult == "" || leftResult == "[]" ? true : false))
                    .leftValue(cleanJsonString(leftResult))
                    .matchRule(matchRule.getMatchRule())
                    .errorMessage(null)
                    .build();
        }


        // 
        try {
            String sanitizedLeft = cleanJsonString(leftResult);
            String sanitizedRight = cleanJsonString(rightResult);

            JsonNode leftNode = objectMapper.readTree(sanitizedLeft);
            JsonNode rightNode = objectMapper.readTree(sanitizedRight);

            if (leftNode.isEmpty()) {
                return createNoMatchResult("Empty left detection results");
            }

            // Compare all fields in the JSON objects
            boolean matches = true;
            StringBuilder leftFilterResult = new StringBuilder("[");
            for (JsonNode leftItem : leftNode) {
                boolean match = true;
                match = compareJsonNodes(leftItem, rightNode, matchRule);
                if (!match) {
                    matches = false;
                    leftFilterResult.append(objectMapper.writeValueAsString(leftItem)).append(",");
                }
            }
            
            String leftFilterResultToString = leftFilterResult.append("]").toString().replace(",]", "]");
            
            return DetectionMatchResultDTO.builder()
                    .matches(matches)
                    .leftValue(leftFilterResultToString)
                    .matchRule(matchRule.getMatchRule())
                    .errorMessage(null)
                    .build();

        } catch (Exception e) {
            log.error("Error comparing results for rule ID: {}", matchRule.getAutoId(), e);
            return createNoMatchResult("Error comparing results: " + e.getMessage());
        }
    }

    private boolean compareJsonNodes(JsonNode leftNode, JsonNode rightNode,
                                     DetectionMatchMetaDTO matchRule) {
        Iterator<String> fieldNames = rightNode.fieldNames();
        while (fieldNames.hasNext()) {
            String fieldName = fieldNames.next();
            JsonNode rightValue = rightNode.get(fieldName);
            
            if (!leftNode.has(fieldName)) {
                return false;
            }
            
            JsonNode leftValue = leftNode.get(fieldName);


            if (leftValue == null) {
                return false;
            }

            if (rightValue == null) {
                if (leftValue.isNumber()) {
                    // For numeric fields, apply match rule comparison
                    if (!evaluateMatchRule(leftValue.asDouble(), 0.0, matchRule)) {
                        return false;
                    }
                } else {
                    // For non-numeric fields, require exact match
                    if (!leftValue.isEmpty()) return false;
                }
            } else {
                if (leftValue.isNumber() && rightValue.isNumber()) {
                    // For numeric fields, apply match rule comparison
                    if (!evaluateMatchRule(leftValue.asDouble(), rightValue.asDouble(), matchRule)) {
                        return false;
                    }
                } else {
                    // For non-numeric fields, require exact match
                    if (!leftValue.equals(rightValue)) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    private boolean evaluateMatchRule(double leftValue, double rightValue,
                                      DetectionMatchMetaDTO matchRule) {
        Double threshold = matchRule.getMatchThreshold() != null ?
                matchRule.getMatchThreshold() : 0.0;

        switch (matchRule.getMatchRule()) {
            case MatchRule.EQUAL:
                return Math.abs(leftValue - rightValue) <= threshold;
            case MatchRule.NOT_EQUAL:
                return Math.abs(leftValue - rightValue) > threshold;
            case MatchRule.GREATER_THAN:
                return leftValue > rightValue + threshold;
            case MatchRule.LESS_THAN:
                return leftValue < rightValue - threshold;
            case MatchRule.GREATER_THAN_EQUAL:
                return leftValue >= rightValue - threshold;
            case MatchRule.LESS_THAN_EQUAL:
                return leftValue <= rightValue + threshold;
            default:
                throw new IllegalArgumentException("Unsupported match rule: " + matchRule.getMatchRule());
        }
    }

    private DetectionMatchResultDTO createNoMatchResult(String errorMessage) {
        return DetectionMatchResultDTO.builder()
                .matches(false)
                .leftValue(null)
                .matchRule(null)
                .errorMessage(errorMessage)
                .build();
    }

    private void saveMatchResult(DetectionMatchMetaDTO matchRule, LocalDate eventDate,
                                 DetectionMatchResultDTO matchResult) {
        String sql = "INSERT INTO web.IMP_DETECTION_MATCH \n" +
                "(left_detection_component_id, right_detection_component_id, event_date, \n" +
                "match_summary, match_result, create_time) \n" +
                "VALUES (:leftId, :rightId, :eventDate, :summary, :result, \n" +
                "CURRENT_TIMESTAMP AT TIME ZONE 'Eastern Standard Time')";

        Map<String, Object> params = new HashMap<>();
        params.put("leftId", matchRule.getLeftdetectionComponentId());
        params.put("rightId", matchRule.getRightdetectionComponentId());
        params.put("eventDate", eventDate);
        params.put("summary", matchResult.isMatches() ? 0 : 1);

        try {
            Map<String, Object> resultDetails = createMatchResultDetails(matchResult, matchRule);
            params.put("result", objectMapper.writeValueAsString(matchResult.getLeftValue()));

            jdbcTemplate.update(sql, params);
        } 
    }

    private Map<String, Object> createMatchResultDetails(DetectionMatchResultDTO matchResult,
                                                         DetectionMatchMetaDTO matchRule) {
        Map<String, Object> resultDetails = new HashMap<>();
        resultDetails.put("leftValue", matchResult.getLeftValue());
        resultDetails.put("matchRule", matchResult.getMatchRule());
        resultDetails.put("matchThreshold", matchRule.getMatchThreshold());
        resultDetails.put("matches", matchResult.isMatches());

        if (matchResult.getErrorMessage() != null) {
            resultDetails.put("error", matchResult.getErrorMessage());
        }

        return resultDetails;
    }

    private void handleMatchRuleError(DetectionMatchMetaDTO matchRule, LocalDate eventDate,
                                      Exception error) {
        DetectionMatchResultDTO errorResult = createNoMatchResult(error.getMessage());
        saveMatchResult(matchRule, eventDate, errorResult);
    }

    private void saveNearMissToIncident(DetectionMatchMetaDTO matchRule, LocalDate eventDate,
                                        DetectionMatchResultDTO matchResult, String department, String description) {
        String sql = "INSERT INTO web.IMP_INCIDENT (" +
                "
                "VALUES (" +
                ":incidentNo, :incidentType, :incidentStatus, :occurrenceDate, :identificationDate, " +
                ":incidentTitle, :identifiedBy, :ownerDepartment, :incidentDescription, " +
                ":riskRating, :primaryRiskType, :primaryLevelIiRisk, :secondaryRiskType, " +
                ":secondaryLevelIiRisk, :primaryOwnerDept, :secondaryOwnerDept, " +
                ":rootCauseCategory, :rootCauseSubcategory, :rootCauseAnalysis, " +
                ":existingControls, :dueDate, :attachmentCount)";

        // Generate random 4 characters for incident number
        int detectionId = matchRule.getLeftdetectionComponentId() / 100;
        String incidentNo = "";
        if (detectionId == 101) {
            try {
                JsonNode idNode = objectMapper.readTree(matchResult.getLeftValue()).get("ID");
                if (idNode != null) {
                    incidentNo = String.format("NM-%d-%s",
                            detectionId,
                            idNode.asText());
                }
           
        } else {
            String randomChars = UUID.randomUUID().toString().substring(0, 4).toUpperCase();
            incidentNo = String.format("NM-%d-%s-%s",
                detectionId,
                eventDate.format(DateTimeFormatter.BASIC_ISO_DATE),
                randomChars);
        }
        
        
        String incidentDesc = "N/A";
        if (matchResult.getLeftValue() != null) {
            String descTemplate = detectionMetadataService.getDetectionDescriptionTemplate(detectionId);
            if (descTemplate.isEmpty()) {
                incidentDesc = matchResult.getLeftValue();
            } else {
                incidentDesc = createDesc(matchResult.getLeftValue(), descTemplate);
            }
        }
        
        Map<String, Object> params = new HashMap<>();
        
        try {
            jdbcTemplate.update(sql, params);
            log.info("Successfully created near miss incident: {}", incidentNo);
        } 
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.service.detection;



@Service
@RequiredArgsConstructor
@Slf4j
public class DetectionMetadataService {
    private final NamedParameterJdbcTemplate jdbcTemplate;
    private final ObjectMapper objectMapper;

    @Cacheable(value = "detectionMetaConfig", key = "#detectionId")
    public DetectionMetaDTO getDetectionMetaConfig(Integer detectionId) {
       
            return jdbcTemplate.queryForObject(sql, params, (rs, rowNum) ->
                    DetectionMetaDTO.builder()
                            .autoId(rs.getLong("auto_id"))
                            .detectionId(rs.getInt("detection_id"))
                            .detectionDept(rs.getString("detection_dept"))
                            .detectionDesc(rs.getString("detection_desc"))
                            .build()
            );
       
    }

    @Cacheable(value = "allDetectionMetas")
    public List<DetectionMetaDTO> getAllDetectionMetas() {
            return jdbcTemplate.query(sql, (rs, rowNum) ->
                    DetectionMetaDTO.builder()
                            .autoId(rs.getLong("auto_id"))
                            .detectionId(rs.getInt("detection_id"))
                            .detectionDept(rs.getString("detection_dept"))
                            .detectionDesc(rs.getString("detection_desc"))
                            .build()
           
    }

    public List<DetectionComponentMetaDTO> getActiveComponentDetections(Integer detectionId) {
       
        return jdbcTemplate.query(sql, params, (rs, rowNum) ->
                DetectionComponentMetaDTO.builder()
                        .autoId(rs.getLong("auto_id"))
                        .detectionComponentId(rs.getInt("detection_component_id"))
                        .componentLabels(rs.getString("component_labels"))
                        .componentDataTypes(rs.getInt("component_data_types"))
                        .detectionComponentSource(rs.getInt("component_detection_source"))
                        .detectionComponentDescription(rs.getString("component_detection_description"))
                        .isActive(rs.getString("is_active"))
                        .build()
        );
    }

    public DetectionDataMartMetaDTO getDetectionDataMartMetaConfig(Integer detectionComponentId) {
     
            return jdbcTemplate.queryForObject(sql, params, (rs, rowNum) ->
                    DetectionDataMartMetaDTO.builder()
                            .autoId(rs.getLong("auto_id"))
                            .detectionComponentId(rs.getInt("detection_component_id"))
                            .sqlTemplate(rs.getString("sql_template"))
                            .sqlParams(rs.getString("sql_params"))
                            .build()
            );
       
    }

    public DetectionExcelMetaDTO getDetectionExcelMetaConfig(Integer detectionComponentId) {
        String sql = "   SELECT * FROM web.IMP_DETECTION_EXCEL_META     WHERE detection_component_id = :detectionComponentId ";
        Map<String, Object> params = Collections.singletonMap("detectionComponentId", detectionComponentId);

        try {
            return jdbcTemplate.queryForObject(sql, params, (rs, rowNum) ->
                    
        }
    }

    public List<DetectionEmailMetaDTO> getAllDetectionEmailConfigs() {
        String sql = "SELECT * FROM web.IMP_DETECTION_EMAIL_META WHERE is_active = 'Y'";

        try {
            return jdbcTemplate.query(sql, (rs, rowNum) ->
                    DetectionEmailMetaDTO.builder()
                            .autoId(rs.getLong("auto_id"))
                            .userName(rs.getString("user_name"))
                            .userDepartment(rs.getString("user_department"))
                            .emailGroupBitmap(rs.getInt("email_group_bitmap"))
                            .isActive(rs.getString("is_active"))
                            .build()
            );
        } catch (Exception e) {
            log.error("Error fetching all detection email configurations", e);
            throw new DetectionServiceException("Failed to get Email configurations", e);
        }
    }
    
    public String getDetectionDescriptionTemplate(Integer detectionId) {
        try {
            String sql = "SELECT string_value FROM web.IMP_DETECTION_DICT " +
                    "WHERE dict_id = 2 AND int_value = :detectionId " ;
            Map<String, Object> params = new HashMap<>();
            params.put("detectionId", detectionId);
            return jdbcTemplate.queryForObject(sql, params, String.class);
        }
    }

    
    private String getEmailAddressFromDict(Integer deptEmailID) {
        try {
            String sql = "SELECT string_value FROM web.IMP_DETECTION_DICT " +
                    "WHERE dict_id = 3 AND int_value = :deptEmailID " ;
            Map<String, Object> params = new HashMap<>();
            params.put("deptEmailID", deptEmailID);
            return jdbcTemplate.queryForObject(sql, params, String.class);
        } 
    }
    
    public String getORMEmail() {
        return getEmailAddressFromDict(1);
    }
    
    public String getORDccEmail() {
        return getEmailAddressFromDict(2);
    }
    
    public String getERMEmail() {
        return getEmailAddressFromDict(3);
    }
    
    public String getNonUserEmail(String department) {
        if ("ADC".equals(department)) {
            return getEmailAddressFromDict(4);
        }
        if ("CLD".equals(department)) {
            return getEmailAddressFromDict(5);
        }
        if ("OSD".equals(department)) {
            return getEmailAddressFromDict(6);
        }
        return "";
    }
    
    public Integer getCountDetectionResult(Integer detectionComponentId, LocalDate eventDate) {
        if (detectionComponentId <= 0) {
            return 0;
        }
        try {
                String sql = "SELECT COUNT(component_detection_result) " +
                        "FROM web.IMP_DETECTION_COMPONENT " +
                        "WHERE detection_component_id = :detectionComponentId " +
                        "AND event_date = :eventDate " +
                        "AND create_time = (SELECT MAX(create_time) " +
                        "                  FROM web.IMP_DETECTION_COMPONENT " +
                        "                  WHERE detection_component_id = :detectionComponentId " +
                        "                  AND event_date = :eventDate " +
                        "                  AND (LEN(component_detection_result) > 2 OR detection_component_id <> 10401))";

                Map<String, Object> params = new HashMap<>();
                params.put("detectionComponentId", detectionComponentId);
                params.put("eventDate", eventDate);

                return jdbcTemplate.queryForObject(sql, params, Integer.class);
        } c
          
    }
    
    public String getDetectionResult(Integer detectionComponentId, LocalDate eventDate) {
        if (detectionComponentId == 0) {
            return "";
        }
        try {
            if (detectionComponentId > 0) {
                String sql = "SELECT component_detection_result " +
                        "FROM web.IMP_DETECTION_COMPONENT " +
                        "WHERE detection_component_id = :detectionComponentId " +
                        "AND event_date = :eventDate " +
                        "AND create_time = (SELECT MAX(create_time) " +
                        "                  FROM web.IMP_DETECTION_COMPONENT " +
                        "                  WHERE detection_component_id = :detectionComponentId " +
                        "                  AND event_date = :eventDate)";

                Map<String, Object> params = new HashMap<>();
                params.put("detectionComponentId", detectionComponentId);
                params.put("eventDate", eventDate);

                return jdbcTemplate.queryForObject(sql, params, String.class);
            } else {
                String sql = "SELECT component_detection_result " +
                        "FROM web.IMP_DETECTION_COMPONENT_CONST_META " +
                        "WHERE detection_component_id = :detectionComponentId";

                Map<String, Object> params = new HashMap<>();
                params.put("detectionComponentId", detectionComponentId);

                return jdbcTemplate.queryForObject(sql, params, String.class);
            }
        } 
    }


    public void saveDetectionResult(Integer detectionComponentId, Object result) {
        String sql = "INSERT INTO web.IMP_DETECTION_COMPONENT " +
                "(detection_component_id, event_date, component_detection_result, create_time) " +
                "VALUES (:detectionComponentId, :eventDate, :result, CURRENT_TIMESTAMP AT TIME ZONE 'Eastern Standard Time')";

        Map<String, Object> params = new HashMap<>();
        params.put("detectionComponentId", detectionComponentId);
        params.put("eventDate", LocalDate.now());

        try {
            params.put("result", result != null ? objectMapper.writeValueAsString(result) : "Failed to detect");
            jdbcTemplate.update(sql, params);
        } 
    }

    public void saveDetectionSummary(Integer detectionId, DetectionMetaDTO detectionMeta,
                                     LocalDate eventDate, String detectionDetail, String detectionStatus) {
        Map<String, Object> matchCounts = getMatchCounts(detectionId, eventDate);
        String nearMissStatus = "Failed".equals(detectionStatus) ? "-" : determineNearMissStatus(matchCounts);

        try {
            Map<String, Object> params = createSummaryParams(detectionId, detectionMeta,
                    eventDate, detectionDetail, matchCounts, nearMissStatus, detectionStatus);
            insertDetectionSummary(params);
        } 
    }

    public DetectionComponentMetaDTO getDetectionCompMetaConfig(Integer detectionComponentId) {
        String sql = "SELECT * FROM web.IMP_DETECTION_COMPONENT_META WHERE detection_component_id = :detectionComponentId";
        Map<String, Object> params = Collections.singletonMap("detectionComponentId", detectionComponentId);

        try {
            return jdbcTemplate.queryForObject(sql, params, (rs, rowNum) ->
                    DetectionComponentMetaDTO.builder()
                            .autoId(rs.getLong("auto_id"))
                            .detectionComponentId(rs.getInt("detection_component_id"))
                            .componentLabels(rs.getString("component_labels"))
                            .componentDataTypes(rs.getInt("component_data_types"))
                            .detectionComponentSource(rs.getInt("component_detection_source"))
                            .detectionComponentDescription(rs.getString("component_detection_description"))
                            .isActive(rs.getString("is_active"))
                            .build()
            );
        } 
    }
    
    public boolean checkIncidentNo(String incidentNo) {
        String sql = "SELECT COUNT(*) FROM web.IMP_INCIDENT WHERE incident_no = :incidentNo";
        Map<String, Object> params = Collections.singletonMap("incidentNo", incidentNo);
        try {
            int count = jdbcTemplate.queryForObject(sql, params, Integer.class);
            return count > 0;
        } 
    }
    
    public boolean doneTodayDetection(Integer detectionId) {
        String sql = "SELECT COUNT(*) FROM web.IMP_DETECTION WHERE detection_id = :detectionId " +
                    "AND event_date = CAST(GETDATE() AS date) AND detection_status = 'Successful' ";
        Map<String, Object> params = new HashMap<>();
        params.put("detectionId", detectionId);

    
        int count = jdbcTemplate.queryForObject(sql, params, Integer.class);
        return count > 0;    
    }
    

    
    public String getFilePatternList(Integer detectionId) {
        try {
         List<DetectionComponentMetaDTO> components = getActiveComponentDetections(detectionId);
         List<DetectionComponentMetaDTO> excelComponents = components.stream()
                 .filter(comp -> comp.getDetectionComponentSource() == 2)
                 .collect(Collectors.toList());
         
         if (excelComponents.isEmpty()) {
             log.info("No Excel components found for detection ID {}", detectionId);
             return "";
         }
         
         List<String> filePatterns = new ArrayList<>();
         for (DetectionComponentMetaDTO component : excelComponents) {
             try {
                 DetectionExcelMetaDTO excelMeta = getDetectionExcelMetaConfig(component.getDetectionComponentId());
                 if (excelMeta != null && excelMeta.getExcelFileName() != null && !excelMeta.getExcelFileName().isEmpty()) {
                     filePatterns.add(excelMeta.getExcelFileName());
                 }
             } catch (Exception e) {
                 log.warn("Error retrieving excelmetadata for component ID {}", component.getDetectionComponentId());
             }
         }
         return String.join("|", filePatterns);
        } c
    }

   

    public Map<String, Object> getMatchCounts(Integer detectionId, LocalDate eventDate) {
        String sql = "SELECT match_result " +
                "FROM web.IMP_DETECTION_MATCH m " +
                "WHERE m.left_detection_component_id / 100 = :detectionId " +
                "AND m.event_date = :eventDate " +
                "AND m.auto_id = (SELECT MAX(auto_id) " +
                "                    FROM web.IMP_DETECTION_MATCH " +
                "                    WHERE left_detection_component_id = m.left_detection_component_id " +
                "                    AND event_date = m.event_date)";

        Map<String, Object> params = new HashMap<>();
        params.put("detectionId", detectionId);
        params.put("eventDate", eventDate);

        Map<String, Object> results = new HashMap<>();
        int toltalMisMatches = 0;
        
       
        return results;
    }

    private String determineNearMissStatus(Map<String, Object> matchCounts) {
        int mismatches = ((Number) matchCounts.get("mismatches")).intValue();
        return String.valueOf(mismatches);
    }

    private Map<String, Object> createSummaryParams(Integer detectionId, DetectionMetaDTO detectionMeta,
                                                    LocalDate eventDate, String detectionDetail, Map<String, Object> matchCounts,
                                                    String nearMissStatus, String detectionStatus) throws Exception {
      
        params.put("eventDetail", objectMapper.writeValueAsString(detailMap));

        return params;
    }

    private Map<String, Object> createMetaDataSummary(Map<String, Object> matchCounts) {
        // int totalMatches = ((Number) matchCounts.get("total")).intValue();
        int mismatches = ((Number) matchCounts.get("mismatches")).intValue();

        Map<String, Object> metaData = new HashMap<>();
        // metaData.put("totalMatches", totalMatches);
        metaData.put("mismatches", mismatches);
        // metaData.put("matchRate", totalMatches > 0 ?
        //        ((totalMatches - mismatches) * 100.0 / totalMatches) : 100);

        return metaData;
    }

    private void insertDetectionSummary(Map<String, Object> params) {
        String sql = "INSERT INTO web.IMP_DETECTION " +
                "(event_date, near_miss_status, detection_status, detection_id, " +
                "detection_dept, detection_desc, detection_meta_data, event_detail, create_time ) " +
                "VALUES (:eventDate, :nearMissStatus, :detectionStatus, :detectionId, " +
                ":detectionDept, :detectionDesc, :detectionMetaData, :eventDetail, CURRENT_TIMESTAMP AT TIME ZONE 'Eastern Standard Time')";

        jdbcTemplate.update(sql, params);
    }

    public Map<String, Object> getDetectionSummary(Integer detectionId, LocalDate eventDate) {
        String sql = "SELECT * FROM web.IMP_DETECTION " +
                "WHERE detection_id = :detectionId " +
                "AND event_date = :eventDate " +
                "AND create_time = (SELECT MAX(create_time) " +
                "                  FROM web.IMP_DETECTION " +
                "                  WHERE detection_id = :detectionId " +
                "                  AND event_date = :eventDate)";

        Map<String, Object> params = new HashMap<>();
        params.put("detectionId", detectionId);
        params.put("eventDate", eventDate);

        return jdbcTemplate.queryForMap(sql, params);
    }
    
    
    public Map<String, Object> getCurrentDaySummary(Integer detectionId) {
        List<Map<String, Object>> todayResult = getRecentDetectionSummary(0);
        Optional<Map<String, Object>>  event = todayResult.stream()
                .filter(map -> map.containsKey("detection_id") && map.get("detection_id") == detectionId).findFirst();
        return event.isPresent() ? event.get() : null;
    }

    public List<Map<String, Object>> getRecentDetectionSummary(Integer nDays) {
        // Get all detection IDs from metadata
        List<DetectionMetaDTO> detectionMetas = getAllDetectionMetas();

        String sql = "WITH latest_records AS ( " +
                "    SELECT detection_id, event_date, create_time, " +
                "           ROW_NUMBER() OVER (PARTITION BY detection_id, event_date ORDER BY create_time DESC) as rn " +
                "    FROM web.IMP_DETECTION " +
                "    WHERE  event_date BETWEEN DATEADD(day, :prevNDays, CAST(GETDATE() AS date)) " +
                "                    AND DATEADD(day, 0, CAST(GETDATE() AS date)) " +
                ") " +
                "SELECT i.auto_id ,i.event_date ,i.near_miss_status ,i.detection_status ,i.detection_id ,i.detection_dept " +
                "       ,i.detection_desc ,i.detection_meta_data ,i.event_detail " +
                "       ,FORMAT(i.create_time, 'yyyy-MM-ddTHH:mm:ss') AS create_time " +
                "FROM web.IMP_DETECTION i " +
                "INNER JOIN latest_records lr " +
                "    ON i.detection_id = lr.detection_id " +
                "    AND i.event_date = lr.event_date " +
                "    AND i.create_time = lr.create_time " +
                "WHERE lr.rn = 1";

        
        
        Map<String, Object> params = new HashMap<>();
        params.put("prevNDays", nDays);
        List<Map<String, Object>> results = jdbcTemplate.queryForList(sql, params);

        // Group results by event_date
        Map<LocalDate, Set<Integer>> dateDetectionMap = results.stream()
                .collect(Collectors.groupingBy(
                        r -> LocalDate.parse(r.get("event_date").toString()),
                        Collectors.mapping(r -> (Integer) r.get("detection_id"), Collectors.toSet())
                ));

        // Get date range from last N days to today
        LocalDate today = LocalDate.now();
        LocalDate nDaysAgo = today.minusDays(-nDays);

        return results;
    }

    public List<Integer> getAllDetectionID() {
        String sql = "SELECT detection_id FROM web.IMP_DETECTION_META";
        return jdbcTemplate.query(sql, (rs, rowNum) -> rs.getInt("detection_id"));
    }
    
    Map<String, Object> getNearMissHist() {
        LocalDate currentDate = LocalDate.now();
        Integer prevYearQuarter = (currentDate.getYear() - 1) * 100 + ((currentDate.getMonthValue() -1) /3 * 3 + 1);
        
        // Get current quarter and generate list of last 5 quarters
        String sql =  "SELECT * FROM  " + 
        "(SELECT d.detection_id, q.year_month AS time_period, " +
                "       COALESCE(h.n_of_near_miss, 0) as n_of_near_miss " +
                "FROM (SELECT DISTINCT detection_id " + 
                "      FROM web.IMP_DETECTION_MONTHLY_HIST " +
                "      WHERE detection_id IN (SELECT int_value FROM web.IMP_DETECTION_DICT WHERE dict_id = 1) " +
                "     ) d " +
                "CROSS JOIN  (" +
                " SELECT TOP 6 year_month" +
                " FROM web.IMP_DETECTION_MONTHLY_HIST" +
                " GROUP BY year_month" +
                " ORDER BY year_month DESC" +
                ")  q " +
                "LEFT JOIN web.IMP_DETECTION_MONTHLY_HIST h " +
                "    ON d.detection_id = h.detection_id " +
                "    AND q.year_month = h.year_month " +
        
        
    

        return resultMap;    
    }
    
    public void  upsertNearMissMonthlyHist() {
        LocalDate currentDate = LocalDate.now();
        String yearMonth = String.format("%d%02d", currentDate.getYear(), currentDate.getMonthValue());
        
        // Calculate month start and end dates
        LocalDate monthStart = LocalDate.of(currentDate.getYear(),  currentDate.getMonthValue(), 1);
        LocalDate monthEnd = monthStart.plusMonths(1).minusDays(1);
        
        String sql =  "MERGE INTO web.IMP_DETECTION_MONTHLY_HIST As target  " + 
                "USING (SELECT :yearMonth as year_month, d.attachment_count as detection_id,   " +
                "         COUNT(0) as n_of_near_miss " +
                "       FROM web.IMP_INCIDENT d  " + 
                "       WHERE CAST(d.identification_date AS Date) BETWEEN :monthStart AND :monthEnd " +
                "       GROUP BY d.attachment_count " + 
                "       ) AS source " +
                "ON target.year_month = source.year_month AND target.detection_id = source.detection_id " +
                "WHEN MATCHED THEN " +
                "  UPDATE SET  n_of_near_miss = source.n_of_near_miss " +
                "WHEN NOT MATCHED THEN " +
                "  INSERT(year_month, detection_id, n_of_near_miss) " +
                "      VALUES(source.year_month, source.detection_id, source.n_of_near_miss);";
                
        


        jdbcTemplate.update(sql, params);
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

<<<BEGIN_CONTENT>>>
package com.web.mra.service.detection;



@Service
@RequiredArgsConstructor
@Slf4j
public class DetectionQuartzService {
    private final DetectionFileService fileService;
    private final DetectionService detectionService;
    private final DetectionMetadataService metadataService;
    
    private final Set<String> loggedDepartments = Collections.synchronizedSet(new HashSet<>());
    private boolean summaryLogged = false;
    private LocalDate lastResetDate = null;
    private boolean osdIncompletedLogged = false;

    private static final Map<String, List<Integer>> DEPARTMENT_DETECTIONS = new HashMap<>();
    static {
        DEPARTMENT_DETECTIONS.put("ADC", Collections.singletonList(101));
        DEPARTMENT_DETECTIONS.put("CLD", Arrays.asList(102, 103, 104));
        DEPARTMENT_DETECTIONS.put("OSD", Arrays.asList(105, 106));
    }
    
    private static final int SPECIAL_DETECTION_ID = 104;
    private static final LocalTime SPECIAL_DETECTION_TIME = LocalTime.of(13, 30);
    private static final LocalTime OSD_CHECK_TIME = LocalTime.of(12, 30);
    
    
    public void hourlyDetetionTask() {
        LocalDate today = LocalDate.now();
        LocalDateTime now = LocalDateTime.now();
        boolean isLastRun = now.getHour() >= 15;
        
        if (lastResetDate == null || !lastResetDate.equals(today)) {
            loggedDepartments.clear();
            summaryLogged = false;
            osdIncompletedLogged = false;
            lastResetDate = today;
            log.info("Logging state reset for new day: {}", today);
        }
        
        // Step 1: Check if all detections are done today
        List<Integer> allDetectionIds = Arrays.asList(101, 102, 103, 104, 105, 106);
        boolean allDone = allDetectionIds.stream()
                .allMatch(id -> metadataService.doneTodayDetection(id));
        
        if (allDone) {
            log.info("All detections completed successfully for today: {}", today);
            if (!summaryLogged) {
                logSummary(today);
                summaryLogged = true;
            }
            checkSharedFolder(isLastRun);
            return ;
        }
        
        // Step 2: Process incomplete detections
        List<String> successfulDetections = new ArrayList<>();
        for (Integer detectionId : allDetectionIds) {
            if (!metadataService.doneTodayDetection(detectionId)) {
                if (detectionId == SPECIAL_DETECTION_ID) {
                    if (now.toLocalTime().isAfter(SPECIAL_DETECTION_TIME)) {
                        try {
                            String result = detectionService.detectNearMiss(detectionId, today, false);
                            if (metadataService.doneTodayDetection(detectionId)) {
                                successfulDetections.add(result);
                                log.info("Successfully ran detection for ID : {} (special case after 12:30 PM", detectionId);
                            }
                        } catch (Exception e) {
                            log.info("Failed to run detection ID : {} (special case)", detectionId, e);
                        }
                    } else {
                        log.info("Skipping detection ID : {} - waiting until aftger 12:30 PM", detectionId);
                    }
                } else {
                    String filePatterns = metadataService.getFilePatternList(detectionId);
                    if (fileService.filesAllReady(filePatterns)) {
                        try {
                            String result = detectionService.detectNearMiss(detectionId, today, false);
                            if (metadataService.doneTodayDetection(detectionId)) {
                                successfulDetections.add(result);
                                log.info("Successfully ran detection for ID : {}", detectionId);
                            }
                        } catch (Exception e) {
                            log.info("Failed to run detection ID : {}", detectionId, e);
                        }
                    } else {
                        log.info("Skipping detection ID : {} - required files not ready", detectionId);
                    }
                }
            }
        }
        
        // Now Check: Log if OSD detections are not all done after 12:30 PM
        if (now.toLocalTime().isAfter(OSD_CHECK_TIME) && !osdIncompletedLogged) {
            List<Integer> osdDetectionIds = DEPARTMENT_DETECTIONS.get("OSD");
            boolean allOsdDone = osdDetectionIds.stream()
                    .allMatch(id -> metadataService.doneTodayDetection(id));
            if (!allOsdDone) {
                List<Integer> notUpload = osdDetectionIds.stream().filter(id -> !metadataService.doneTodayDetection(id)).collect(Collectors.toList());
                detectionService.SendEmailUpload(notUpload);
                log.info("OSD department detections (105, 106) are not ready for all files uploading after 12:30 PM on {}", today);
                osdIncompletedLogged = true;
            }
        }
            
        // Step 3: Check department completion
        checkDepartmentCompletion(today, isLastRun);
        
        // Step 4: Check overall completion and handle last run
        checkOverallCompletion(today, isLastRun);
        
        // Step 5: Check if files existing in shared folder
        checkSharedFolder(isLastRun);
    }
    
    private void checkDepartmentCompletion(LocalDate today, boolean isLastRun) {
        // log.info("Enter checkDepartmentCompletion ");
        for (Map.Entry<String, List<Integer>> entry : DEPARTMENT_DETECTIONS.entrySet()) {
            String department = entry.getKey();
            List<Integer> detectionIds = entry.getValue();
            
            boolean allDeptDone = detectionIds.stream()
                    .allMatch(id -> metadataService.doneTodayDetection(id));
            
            log.info("Detection by  dept {}, status {} ", department, allDeptDone);
            if ((allDeptDone|| isLastRun) && !loggedDepartments.contains(department)) {
                detectionService.SendEmailNearMissEvents(department);
                log.info("All detection tasks completed for department: {}", department);
                loggedDepartments.add(department);
            }
        }
    }
    
    private void checkOverallCompletion(LocalDate today, boolean isLastRun) {
        // log.info("Enter checkOverallCompletion ");
        List<Integer> allDetectionIds = Arrays.asList(101, 102, 103, 104, 105, 106);
        boolean allDone = allDetectionIds.stream()
                    .allMatch(id -> metadataService.doneTodayDetection(id));
            
        if ((allDone || isLastRun) && (!summaryLogged)) {
            logSummary(today);
            summaryLogged = true;
        }
    }
    
    private void logSummary(LocalDate today) {
        // send email to ORD
        log.info("Generate summary for all detections {}", today);
        detectionService.SendEmailNearMissEvents("ORD");
        metadataService.upsertNearMissMonthlyHist();
    }
    
    private void checkSharedFolder(boolean isLastRun) {
        if (!isLastRun) {
            return;
        }
        String filesInSharedFolder = fileService.hasFileInSharedFolder();
        if (filesInSharedFolder != null && filesInSharedFolder.length() > 0) {
            // send email to ERM
            log.info("Send email to ERM Admin for file existing in shared folder ");
            detectionService.SendEmailNearMissEvents("ERM");
        }
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

<<<BEGIN_CONTENT>>>
package com.web.mra.service.detection;




/**
 * Represents the result of a detection component execution.
 */
@Getter
@RequiredArgsConstructor
public class DetectionResult {
    private final Integer detectionComponentId;
    private final Object result;
    private final Exception error;

}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>

package com.web.mra.service.detection;

@Service
@RequiredArgsConstructor
@Slf4j
public class DetectionService {
    private final DetectionDataMartService dataMartService;
    private final DetectionExcelService excelService;
    private final DetectionMatchService matchService;
    private final DetectionMetadataService metadataService;
    private final DetectionEmailService detectionEmailService;
    private final DetectionFileService fileService;
    private final ExecutorService executorService = Executors.newFixedThreadPool(10);
    private final ObjectMapper objectMapper;
    
    @Autowired
    private IncidentService incidentService;

    @Transactional
    public String detectNearMiss(Integer detectionId, LocalDate eventDate, boolean forceDetection) {
        try {
            validateDetectionId(detectionId);
            LocalDate effectiveDate = eventDate != null ? eventDate : LocalDate.now();
            
            // Skip if already done today's detection
            if (!forceDetection && metadataService.doneTodayDetection(detectionId)) {
                log.info(" SKIP Detection {}, already done today", detectionId);
                Map<String, Object> detectionSummmary = metadataService.getDetectionSummary(detectionId, effectiveDate);
                return objectMapper.writeValueAsString(detectionSummmary);
            }

            DetectionMetaDTO detectionMeta = metadataService.getDetectionMetaConfig(detectionId);
            if (detectionMeta == null) {
                throw new DetectionServiceException("No detection metadata found for ID: " + detectionId);
            }

            List<DetectionComponentMetaDTO> componentMetas = metadataService.getActiveComponentDetections(detectionId);
            List<CompletableFuture<DetectionResult>> futures = executeComponentDetections(componentMetas, forceDetection);
            processDetectionResults(detectionId, effectiveDate, detectionMeta, futures);

            Map<String, Object> detectionSummary = metadataService.getDetectionSummary(detectionId, effectiveDate);
            return objectMapper.writeValueAsString(detectionSummary);
        } catch (Exception e) {
            String errorMsg = String.format("Near miss detection failed for ID: %d and date: %s", detectionId,
                    eventDate);
            log.error(errorMsg, e);
            throw new DetectionServiceException(errorMsg, e);
        }
    }
    
    public List<String> fileTriggerDetection(List<String> fileList) {
        List<Integer> detectionIds = metadataService.getAllDetectionID();
        List<String> results = new ArrayList<>();
        LocalDate today = LocalDate.now();
        for (Integer detectionId : detectionIds) {
            try {
                String filePatterns = metadataService.getFilePatternList(detectionId);
                
                if (!filePatterns.isEmpty() && 
                    fileService.fileInPattern(fileList, filePatterns) &&
                    fileService.filesAllReady(filePatterns)) {
                    
                    String result = detectNearMiss(detectionId, today, false);
                    results.add(result);
                }
            } catch (Exception e) {
                log.error("Failed to process file trigger detection for ID: " + detectionId, e);
            }
        }
        
        return results;
    }

    public List<String> detectAllNearMiss() {
        List<Integer> detectionIds = metadataService.getAllDetectionID();
        List<String> results = new ArrayList<>();
        LocalDate today = LocalDate.now();

        for (Integer detectionId : detectionIds) {
            try {
                String result = detectNearMiss(detectionId, today, false);
                results.add(result);
            } catch (Exception e) {
                log.error("Failed to detect near miss for ID: " + detectionId, e);
            }
        }
        return results;
    }

    public Map<String, Object> getNearMissHistory() {
        return metadataService.getNearMissHist();
    }
    
    public Map<String, Object> getWeeklyNearMiss() {
        List<Map<String, Object>> weeklyEvents = metadataService.getRecentDetectionSummary(-7);
        Map<String, Object> resultMap = new HashMap<>();
        resultMap.put("detections", weeklyEvents);
        return resultMap;
    }
    
    public Boolean SendEmailUpload(List<Integer> ids) {
        log.info(" upload file reminder ");
        List<DetectionEmailMetaDTO> emailConfigs = metadataService.getAllDetectionEmailConfigs();
        try {
            Map<String, String> status = new HashMap<>();
            for (Integer id : ids) {
                Map<String, Object> summary = metadataService.getCurrentDaySummary(id);
                status.put(String.valueOf(summary.get("detection_desc")), String.valueOf(summary.get("detection_status")));
            }
            String nonUserEmails = metadataService.getNonUserEmail("OSD");
            detectionEmailService.SendEmailNearMissEventUploadFiles(emailConfigs, status, nonUserEmails);
        } catch (Exception e) {
            log.error("Failed to send uploading file reminder emails", e);
            return Boolean.FALSE;
        }
        return Boolean.TRUE;
    }
    
    public Boolean SendEmailNearMissEvents(String department) {
        log.info(" near miss events ");
        List<DetectionMetaDTO> allDetections = metadataService.getAllDetectionMetas();
        List<DetectionEmailMetaDTO> emailConfigs = metadataService.getAllDetectionEmailConfigs();

        try {
            Map<String, List<DetectionMetaDTO>> detectionsByDept = allDetections.stream().collect(Collectors.groupingBy(DetectionMetaDTO::getDetectionDept));

            if (department.equals("ERM")) {
                // ERM
                String ermEmail = metadataService.getERMEmail();
                String fileList = fileService.hasFileInSharedFolder();
                detectionEmailService.SendEmailNearMissEventsDetectedERM(fileList, ermEmail);
            } else if (department.equals("ORD") == false) {
                // OSD, CLD, ADC
                Map<String, String> nearMissCount = new HashMap<>();
                Map<String, String> nearMissStatus = new HashMap<>();
                Map<String, String> nearMissRunTime = new HashMap<>();
                int totalCount = 0;
                for (Map.Entry<String, List<DetectionMetaDTO>> entry : detectionsByDept.entrySet()) {
                    // only calculate related department
                    if (entry.getKey().equals(department) == false) {
                        continue;
                    }
                    List<DetectionMetaDTO> deptDetections = entry.getValue();
                    for (DetectionMetaDTO detection : deptDetections) {
                        Map<String, Object> summary = metadataService.getCurrentDaySummary(detection.getDetectionId());
                        String near_miss_status_num = String.valueOf(summary.get("near_miss_status"));
                        String near_miss_name = String.valueOf(summary.get("detection_desc"));
                        String near_miss_status = String.valueOf(summary.get("detection_status"));
                        String near_miss_runtime = "";
                        if (String.valueOf(summary.get("create_time")).length() < 10) {
                            near_miss_runtime = "";
                        } else {
                            near_miss_runtime = String.valueOf(summary.get("create_time")).substring(0, 10);
                            if (String.valueOf(summary.get("create_time")).length() > 10) near_miss_runtime += " " + String.valueOf(summary.get("create_time")).substring(11, 16);
                        }
                        nearMissCount.put(near_miss_name, near_miss_status_num);
                        nearMissStatus.put(near_miss_name, near_miss_status);
                        nearMissRunTime.put(near_miss_name, near_miss_runtime);
                        if (near_miss_status_num.equals("-") != true) totalCount += Integer.parseInt(near_miss_status_num);
                    }
                }
                String nonUserEmails = metadataService.getNonUserEmail(department);
                detectionEmailService.SendEmailNearMissEventsDetectedNonORD(department, emailConfigs, nonUserEmails, totalCount, nearMissCount, nearMissStatus, nearMissRunTime);
            } else {
                // ORD
                Map<String, String> nearMissCount = new HashMap<>();
                Map<String, String> nearMissStatus = new HashMap<>();
                Map<String, String> nearMissRunTime = new HashMap<>();
                Map<String, String> nearMissDept = new HashMap<>();
                int totalCount = 0;
                
                for (Map.Entry<String, List<DetectionMetaDTO>> entry : detectionsByDept.entrySet()) {
                    List<DetectionMetaDTO> deptDetections = entry.getValue();
                    for (DetectionMetaDTO detection : deptDetections) {
                        Map<String, Object> summary = metadataService.getCurrentDaySummary(detection.getDetectionId());
                        
                        String near_miss_status_num = String.valueOf(summary.get("near_miss_status"));
                        String near_miss_name = String.valueOf(summary.get("detection_desc"));
                        String near_miss_status = String.valueOf(summary.get("detection_status"));
                        String near_miss_runtime = "";
                        if (String.valueOf(summary.get("create_time")).length() < 10) {
                            near_miss_runtime = "";
                        } else {
                            near_miss_runtime = String.valueOf(summary.get("create_time")).substring(0, 10);
                            if (String.valueOf(summary.get("create_time")).length() > 10) near_miss_runtime += " " + String.valueOf(summary.get("create_time")).substring(11, 16);

                        }
                        String near_miss_dept = String.valueOf(summary.get("detection_dept"));
                        nearMissCount.put(near_miss_name, near_miss_status_num);
                        nearMissStatus.put(near_miss_name, near_miss_status);
                        nearMissRunTime.put(near_miss_name, near_miss_runtime);
                        nearMissDept.put(near_miss_name, near_miss_dept);
                        if (near_miss_status_num.equals("-") != true) totalCount += Integer.parseInt(near_miss_status_num);
                    }
                }
                
                String ormEmail = metadataService.getORMEmail();
                
                String ccEmail = metadataService.getORDccEmail();
                detectionEmailService.SendEmailNearMissEventsDetectedORD(totalCount, nearMissCount, nearMissStatus, nearMissRunTime, nearMissDept, 
                        exportTodayIncident(), ormEmail, ccEmail);
            }
        } catch (Exception e) {
            log.error("Failed to send detection summary emails", e);
            return Boolean.FALSE;
        }
        return Boolean.TRUE;
    }

    public String exportTodayIncident() {
        try {
            Map<String, Object> map = new HashMap<>();
            LocalDate today = LocalDate.now();
            map.put("identificationDateFrom", today);
            map.put("identificationDateTo", today);

            List<IncidentExport> incidentExportList = incidentService.exportIncident(map);
            
            if (incidentExportList.size() == 0) {
                return "";
            }
            
            ExcelUtil<IncidentExport> incidentExcelUtil = new ExcelUtil<>(IncidentExport.class);
            // return fileService.saveWBtoFile(incidentExcelUtil.buildExcel(incidentExportList, "Sheet1", "Near Miss Events"));
            return fileService.saveWBtoFile(incidentExcelUtil.buildExcel(incidentExportList, "Sheet1", null));
        } catch (Exception e){
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }
    
    private List<CompletableFuture<DetectionResult>> executeComponentDetections(
            List<DetectionComponentMetaDTO> componentMetas, boolean forceDetection) {
        List<CompletableFuture<DetectionResult>> futures = new ArrayList<>();

        for (DetectionComponentMetaDTO componentMeta : componentMetas) {
            CompletableFuture<DetectionResult> future = CompletableFuture.supplyAsync(() -> {
                try {
                    Object result = executedetectionComponent(componentMeta.getDetectionComponentId(), forceDetection);
                    return new DetectionResult(componentMeta.getDetectionComponentId(), result, null);
                } catch (Exception e) {
                    log.error("Component detection failed", e);
                    return new DetectionResult(componentMeta.getDetectionComponentId(), null, e);
                }
            }, executorService);
            futures.add(future);
        }

        return futures;
    }

    private void processDetectionResults(Integer detectionId, LocalDate effectiveDate, DetectionMetaDTO detectionMeta,
            List<CompletableFuture<DetectionResult>> futures) {
        boolean allSuccess = true;
        StringBuilder detectionDetail = new StringBuilder();
        List<Integer> failedComponentIds = new ArrayList<>();

        for (CompletableFuture<DetectionResult> future : futures) {
            try {
                DetectionResult result = future.get(5, TimeUnit.MINUTES);
                Integer componentId = result.getDetectionComponentId();
                Object resultValue = result.getResult();
                boolean isEmpty = resultValue == null || resultValue.toString().trim().isEmpty()
                        || "{}".equals(resultValue.toString().trim()) || result.getError() != null;

                if (isEmpty) {
                    allSuccess = false;
                    failedComponentIds.add(componentId);
                    if (result.getError() != null) {
                        detectionDetail.append(" - ").append(result.getError().getMessage());
                    }
                    metadataService.notifyFailure(detectionId, componentId,
                            result.getError() != null ? result.getError().getMessage() : "Empty detection");
                } else {
                    log.info(" detect successful");
                }
            } catch (Exception e) {
                allSuccess = false;
                handleDetectionError(detectionDetail, e);
            }
        }

        if (allSuccess) {
            String matchResult = matchService.executeMatchByDate(detectionId, effectiveDate);
            detectionDetail.append(matchResult);
            metadataService.saveDetectionSummary(detectionId, detectionMeta, effectiveDate,
                    cleanJsonString(detectionDetail.toString()), "Successful");
        } else {
            log.info("Detection failed due to component issues: {}", failedComponentIds);
            metadataService.saveDetectionSummary(detectionId, detectionMeta, effectiveDate,
                    cleanJsonString(detectionDetail.toString()), "Failed");
        }
    }

    private Object executedetectionComponent(Integer detectionComponentId, boolean forceDetection) {
        if (detectionComponentId < 0) {
            return null;
        }
        
        // Check if today's detection result already exists
        Integer countDetection =  metadataService.getCountDetectionResult(detectionComponentId, LocalDate.now());
        
        if (!forceDetection && countDetection > 0) {
            String existingResult = metadataService.getDetectionResult(detectionComponentId, LocalDate.now());
            if (existingResult != null && !existingResult.isEmpty()) {
                log.info("Detection result already exists for component ID {} on date: {}", detectionComponentId, LocalDate.now());
                return existingResult;
            }
        }

        DetectionComponentMetaDTO componentMeta = metadataService.getDetectionCompMetaConfig(detectionComponentId);
        validateComponentMeta(componentMeta, detectionComponentId);

        try {
            Object detectionResult = executeDetectionBySource(detectionComponentId, componentMeta);
            String resultString = cleanJsonString((String) detectionResult);
            metadataService.saveDetectionResult(detectionComponentId, resultString);
            return resultString;
        } catch (Exception e) {
            log.error("Error executing detection for component ID: {}", detectionComponentId, e);
            throw new DetectionServiceException("Detection execution failed", e);
        }
    }

    private Object executeDetectionBySource(Integer detectionComponentId, DetectionComponentMetaDTO componentMeta) {
        Integer source = componentMeta.getDetectionComponentSource();

        switch (source) {
        case DetectionSource.DATA_MART:
            return dataMartService.detectDataMart(metadataService.getDetectionDataMartMetaConfig(detectionComponentId));
        case DetectionSource.EXCEL:
            return excelService.detectExcel(metadataService.getDetectionExcelMetaConfig(detectionComponentId));
        default:
            throw new IllegalArgumentException("Unsupported detection source type: " + source);
        }
    }

    private void validateDetectionId(Integer detectionId) {
        if (detectionId == null || detectionId <= 0) {
            throw new IllegalArgumentException("Invalid Detection ID: " + detectionId);
        }
    }

    private void validateComponentMeta(DetectionComponentMetaDTO componentMeta, Integer detectionComponentId) {
        if (componentMeta == null) {
            throw new IllegalArgumentException("No metadata found for detection ID: " + detectionComponentId);
        }
        if (!"Y".equals(componentMeta.getIsActive())) {
            log.warn("Detection component {} is inactive", detectionComponentId);
        }
    }

    private void handleDetectionError(StringBuilder detectionDetail, Exception e) {
        if (e instanceof TimeoutException) {
            detectionDetail.append("Component execution timed out\n");
            log.error("Detection timeout", e);
        } else {
            detectionDetail.append("Component execution failed: ").append(e.getMessage()).append("\n");
            log.error("Detection execution error", e);
        }
    }

    @Override
    protected void finalize() {
        try {
            executorService.shutdown();
            if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } 
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>

<<<BEGIN_FILE>>>
RelativePath:java\com\web\mra\service\detection
FileName:MatchRule.java
FileSize:1699
<<<BEGIN_CONTENT>>>
// MatchRule.java
package com.web.mra.service.detection;

/**
 * Constants defining different types of match rules for detection comparison.
 */
public final class MatchRule {
   
    /**
     * Get the string representation of a match rule type.
     *
     * @param value The match rule value
     * @return String representation of the match rule
     * @throws IllegalArgumentException if the value is invalid
     */
    public static String getRuleName(int value) {
        switch (value) {
            case EQUAL:
                return "EQUAL";
            case NOT_EQUAL:
                return "NOT_EQUAL";
            case GREATER_THAN:
                return "GREATER_THAN";
            case LESS_THAN:
                return "LESS_THAN";
            case GREATER_THAN_EQUAL:
                return "GREATER_THAN_EQUAL";
            case LESS_THAN_EQUAL:
                return "LESS_THAN_EQUAL";
            default:
                throw new IllegalArgumentException("Invalid match rule: " + value);
        }
    }

    /**
     * Validate if a match rule value is valid.
     *
     * @param value The match rule value to validate
     * @return true if valid, false otherwise
     */
    public static boolean isValidRule(int value) {
        return value >= EQUAL && value <= LESS_THAN_EQUAL;
    }
}
<<<END_CONTENT>>>
<<<END_FILE>>>
<<<BEGIN_FILE>>>
RelativePath:java\com\web\mra\service
FileName:DynamicTableService.java
FileSize:6341
<<<BEGIN_CONTENT>>>
package com.web.mra.service;


@Service
@RequiredArgsConstructor
@Slf4j
public class DynamicTableService {

    private final NamedParameterJdbcTemplate jdbcTemplate;
    private final AuditService auditService;
    
    private static final Set<String> WRITEABLE_ALLOWED_TABLES = new HashSet<>(Arrays.asList("IMP_DETECTION_DICT", "IMP_DETECTION_EXCEL_META"));
    
    private static final Set<String> READABLE_ONLY_ALLOWED_TABLES = new HashSet<>(Arrays.asList("IMP_DETECTION", "IMP_DETECTION_AUDIT_TRAIL"));


    public boolean isWriteableTable(String tableAlias) {
        if (tableAlias == null || tableAlias.trim().isEmpty()) {
            throw new IllegalArgumentException("Table name cannot be null or empty");
        }
        return WRITEABLE_ALLOWED_TABLES.contains(tableAlias);
    }
    
    public boolean isReadableTable(String tableAlias) {
        if (tableAlias == null || tableAlias.trim().isEmpty()) {
            throw new IllegalArgumentException("Table name cannot be null or empty");
        }
        return WRITEABLE_ALLOWED_TABLES.contains(tableAlias) || READABLE_ONLY_ALLOWED_TABLES.contains(tableAlias);
    }
    
    
    public PageResponse<Map<String, Object>> getTableData(
            String tableAlias, int page, int size
    ) {
        if (!isReadableTable(tableAlias)) {
            throw new IllegalArgumentException("Table " + tableAlias + " is not readable");
        }
        
        String sql = "";
        if ("IMP_DETECTION".equals(tableAlias.toUpperCase())) {
           sql = "SELECT *, FORMAT(create_time, 'yyyy-MM-ddTHH:mm:ss') AS create_time_ets  FROM web.IMP_DETECTION ORDER BY auto_id DESC " ; 
        } else if ("IMP_DETECTION_EXCEL_META".equals(tableAlias.toUpperCase())) {
            sql = "SELECT * FROM web.IMP_DETECTION_EXCEL_META ORDER BY auto_id ASC " ;      
        } else if ("IMP_DETECTION_DICT".equals(tableAlias.toUpperCase())) {
             sql = "SELECT * FROM web.IMP_DETECTION_DICT ORDER BY auto_id ASC " ;      
        } else if ("IMP_DETECTION_AUDIT_TRAIL".equals(tableAlias.toUpperCase())) {
             sql = "SELECT * FROM web.IMP_DETECTION_AUDIT_TRAIL ORDER BY auto_id DESC " ;      
        } else {
            return null;
        }
       
        // Execute query
        Map<String, Object> params = new HashMap<>();

        List<Map<String, Object>> content = jdbcTemplate.queryForList(
                sql, params
        );

        // Get total count
        long total = content.size();

        // Create response
        PageResponse<Map<String, Object>> response = new PageResponse<>();
        response.setContent(content);
        response.setTotal(total);
        response.setPage(page);
        response.setSize(size);

        return response;
    }

   

    public Map<String, Object> updateRecord(
            String tableAlias, Long id, Map<String, Object> record
    ) {
        if (!isWriteableTable(tableAlias)) {
            throw new IllegalArgumentException("Table " + tableAlias + " is not writeable");
        }
        // Remove null values and ensure id matches
        Map<String, Object> oldRecord = getRecordById(tableAlias, id);
        record.values().removeIf(Objects::isNull);

        String sql = "";
        Map<String, Object> params = new HashMap<>();
        params.put("auto_id", id);
        
        if ("IMP_DETECTION_DICT".equals(tableAlias.toUpperCase()) && record.containsKey("string_value")) {
            params.put("string_value", record.get("string_value"));
            sql = "UPDATE web.IMP_DETECTION_DICT SET string_value = :string_value WHERE auto_id = :auto_id";
        } else if ("IMP_DETECTION_EXCEL_META".equals(tableAlias.toUpperCase()) && record.containsKey("cell_params")) {
            params.put("cell_params", record.get("cell_params"));
             sql = "UPDATE web.IMP_DETECTION_EXCEL_META SET cell_params = :cell_params WHERE auto_id = :auto_id" ;      
        } else {
            return null;
        }
       

        jdbcTemplate.update(sql, new MapSqlParameterSource(params));
        
        Map<String, Object> updatedRecord = getRecordById(tableAlias, id);
        
        record.forEach((field, newValue) -> {
            if ("string_value".equals(field) || "cell_params".equals(field)) {
                Object oldValue = oldRecord.get(field);
                if (!Objects.equals(oldValue, newValue)) {
                    auditService.logAudit(null, "UPDATE", "Updated record in " + tableAlias + " with ID: " + id,
                            tableAlias, field, 
                            oldValue != null ? oldValue.toString() : null, 
                            newValue != null ? newValue.toString() : null
                    );
                }
            }
        });
        return updatedRecord;
    }

    private Map<String, Object> getRecordById(String tableAlias, Long id) {
        if (!isReadableTable(tableAlias)) {
            throw new IllegalArgumentException("Table " + tableAlias + " is not readable");
        }
        String sql = "";
        if ("IMP_DETECTION_DICT".equals(tableAlias.toUpperCase())) {
            sql = "SELECT * FROM web.IMP_DETECTION_DICT WHERE auto_id = :id";
        } else if ("IMP_DETECTION_EXCEL_META".equals(tableAlias.toUpperCase())) {
              sql = "SELECT * FROM web.IMP_DETECTION_EXCEL_META WHERE auto_id = :id" ;      
        } else if ("IMP_DETECTION".equals(tableAlias.toUpperCase())) {
            sql = "SELECT * FROM web.IMP_DETECTION WHERE auto_id = :id";
        } else {
            return null;
        }

        Map<String, Object> params = new HashMap<>();
        params.put("id", id);

        return jdbcTemplate.queryForMap(sql, params);
    }
}

<<<END_CONTENT>>>
<<<END_FILE>>>
